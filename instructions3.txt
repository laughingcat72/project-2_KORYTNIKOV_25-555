Декораторы — это один из мощных инструментов Python, позволяющий изменять поведение функций или классов без изменения их исходного кода. Декораторы часто применяются для решения таких задач, как логирование, контроль доступа, кэширование, валидация данных и многое другое. Наш проект уже функционален, но хороший код — это не только работающий код. На этом финальном этапе мы сфокусируемся на качестве: сделаем наш код более надежным, читаемым и профессиональным с помощью продвинутых концепций Python — декораторов и замыканий. Мы вынесем повторяющуюся логику, централизуем обработку ошибок и добавим полезные "обертки" для наших основных функций.
Применение декораторов для улучшения кода
Декораторы позволяют добавлять функциональность к существующим функциям, не изменяя их код. Это идеальный инструмент для таких задач, как логирование, проверка прав или обработка ошибок.
Одной из частых задач в проекте является обработка ошибок. Если каждая команда, связанная с базой данных, может генерировать исключения (например, неверный ввод данных или отсутствие таблицы), декораторы помогут вынести логику обработки ошибок за пределы основного кода.
Например, мы можем создать декоратор, который будет автоматически обрабатывать исключения и выводить сообщения об ошибках:
 

def handle_db_errors(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except FileNotFoundError:
            print("Ошибка: Файл данных не найден. Возможно, база данных не инициализирована.")
        except KeyError as e:
            print(f"Ошибка: Таблица или столбец {e} не найден.")
        except ValueError as e:
            print(f"Ошибка валидации: {e}")
        except Exception as e:
            print(f"Произошла непредвиденная ошибка: {e}")
    return wrapper

@handle_db_errors
def some_db_operation():
    # ... код, который может вызвать ошибку
    pass 

 
Таким образом, мы можем централизовать логику обработки ошибок, избегая дублирования кода в каждой функции.
Задачи

    Создайте модуль для декораторов. В директории src создайте файл decorators.py.
    Реализуйте декоратор handle_db_errors.
        Создайте декоратор, который оборачивает вызов функции в блок try...except.
        Он должен перехватывать как минимум KeyError (например, обращение к несуществующей таблице), ValueError (ошибки валидации типов) и FileNotFoundError.
        Примените этот декоратор ко всем функциям в db_core, которые могут вызвать эти исключения. Теперь вам не нужно писать try...except в каждой из них.
    Реализуйте декоратор confirm_action(action_name).
        Это должен быть декоратор с аргументом (фабрика декораторов). Он будет запрашивать у пользователя подтверждение для опасных операций.
        Пример использования:
     

     @confirm_action("удаление таблицы")
     def drop_table(metadata, table_name):
         # ... логика удаления
         pass
      

     
        Перед выполнением drop_table в консоли должно появиться: Вы уверены, что хотите выполнить "удаление таблицы"? [y/n]:. Если пользователь вводит не "y", операция отменяется.
        Примените этот декоратор к функциям drop_table и delete в core.
    Реализуйте декоратор log_time.
        Этот декоратор должен замерять время выполнения функции и выводить его в консоль.
        Используйте модуль time (time.monotonic()).
        Вывод должен быть в формате: Функция <имя_функции> выполнилась за X.XXX секунд.
        Примените этот декоратор к "медленным" операциям, которые работают с файлами, например, select и insert.
    Реализуйте функцию с замыканием для кэширования.
        Напишите функцию create_cacher(), которая возвращает внутреннюю функцию cache_result(key, value_func).
        Внутренняя функция должна хранить кэш (словарь) в своем замыкании.
        При вызове она сначала проверяет, есть ли результат в кэше по ключу. Если есть — возвращает его. Если нет — вызывает value_func (функцию для получения данных), сохраняет результат в кэш и возвращает его.
        Интегрируйте этот механизм в операцию select, чтобы кэшировать результаты одинаковых запросов.
    Проведите рефакторинг.
        Убедитесь, что все декораторы применены к нужным функциям.
        Удалите дублирующиеся блоки try...except из db_core, так как теперь их работу выполняет декоратор.
        Проверьте весь проект с помощью make lint и исправьте все найденные ошибки.
    Финальное README.md и asciinema.
        Обновите README.md, добавив информацию о новых возможностях (обработка ошибок, подтверждение действий).
        Запишите финальную asciinema, демонстрирующую работу декораторов (например, запрос на подтверждение удаления)

